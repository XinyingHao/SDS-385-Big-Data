####################   Estimation  ########################

###################   Read the data     ###################
data <- read.csv("data.csv")
#T.ex*(n,Par,Ad,t,emotion,dt,Zapt,tau,z,Ad)

## Indexs
I<- length(levels(factor(data[,2])))        #Number of sub
#J <- length(levels(factor(data[,3])))      #Number of ads
#Sub-Sample
#sample<-sample(1:532,100,replace=FALSE)
M <- 7
J <- 16
T <- 2700/15                                 #Number of maximum watching duration
N <- nrow(data)/T                            #Number of viewing instance
P <- 8                                       #Number of emotions
K <- 10000                                   #Number of iterations

####
e.ar <-as.matrix(data[,6:12])
for(i in 1:ncol(e.ar)){
  for (j in 1:nrow(e.ar)){
    e.ar[j,i] <- min(1,e.ar[j,i])
    e.ar[j,i] <- max(0,e.ar[j,i])
  }
}

e.star <- aperm(array (e.ar,c(T,N,P)),c(2,1,3))
d <- aperm(array(data[,15], c(T,N)),c(2,1))
d.mod <- abind(array(0,c(N,1)),d)   
tau <- aperm(array (data[,17],c(T,N)),c(2,1))
tau.mod <- abind(array(0,c(N,1)),tau)
tau.sum <- tau[,1]

Zap <- aperm(array(data[,16], c(T,N)),c(2,1))
z <- aperm(array (as.matrix(data[,18:24]),c(T,N,M)),c(2,1,3))
z.mod <- abind(array(0,c(N,1,M)),z,along=2)
Ad.raw <- aperm(array(data[,25], c(T,N)),c(2,1))
Ad.dummy <- function(x){
  Ad.d <- rep(0,J)
  Ad.d[x] <-1
  return(Ad.d)
}
Ad <- aaply(Ad.raw,c(1,2),Ad.dummy)
Ad.mod <- abind(array(0,c(N,1,J)),Ad,along=2)




#-------------------------------------------------------------------------------------------------------------------------------------------#
#################################################           Or simulate data              ################################################### 
N <- 300
I <- 100
J <- 2        # number of dummy variables
JJ <-3        # number of ads
P <- 2
M <- 2
s <- 1        #frames per second (Real Data s=30)
T <- 60 * s

set.seed(1234)

#True Pamarter
t.r.e <- c(2,2)
t.u.e <- c(-0.3,-0.3)
t.delta <- c(1,1)
#t.V <- matrix(c(0.25,0.001,0.001,0.25),P,P)
#t.W <- matrix(c(0.25,0.001,0.001,0.25),P,P)
t.V <- diag(0.25,P)
t.W <- diag(0.25,P)
t.beta <- c(1.3,-3.5)
#t.beta.tilda <- c(0.5,2,0.1,0.1,0.5,0.8,-3)
t.beta.tilda <- c(1,3,0.1,0.1,0.5,0.8,-2)
#t.beta.tilda <- c(1,0,0.1,0.1,0.5,0.8,-2)
t.sigma.w2 <- 0.6

t.e.0 <- array(0, c(N,T,P))
simulate.e <- function(x){ # simulate e for each n
	# Simulate d ~ multinormal
	d <- sample(c(rep(0,10), rep(5,10), 6:15), 1, replace = T)
	dt <- c(0,rep(1,d*s),rep(0,(T-d)*s))
	#Initialization for e, e.star
	e <- matrix(0, P, T+1)               
	e.star <- matrix(0, P, T+1)
	e[,1] <- rmvnorm(1,c(0.5,0.5),t.W)
	e.star[,1] <- rmvnorm(1,e[,1], t.V)
	#Initialization for z, Ad
	z <- sample(1:10, M, replace = T)
	Ad <- sample(c(0,0,1), JJ, replace = F)[2:3]
	#Initialization for y, y.star
	y <- rep(0,T+1)
	y.star <- rep(0,T+1)
	Zap <- rep(0,T+1)
	y[1] <- rnorm(1,-5,sqrt(t.sigma.w2))
	y.star[1] <- rnorm(1,y[1],1)
	for(t in 2:(T+1)){
		e[,t] <- rmvnorm(1,diag(t.delta) %*% e[,t-1] + t.r.e* dt[t] + t.u.e , t.W)
		e.star[,t] <- rmvnorm(1,e[,t], t.V)
		y[t] <- rnorm(1,t.beta.tilda[1]*y[t-1]+crossprod(t.beta,e[,t-1])+ crossprod(t.beta.tilda[2:(M+J+3)],c(dt[t],z,Ad,1)), sqrt(t.sigma.w2))
		y.star[t] <- rnorm(1,y[t],1)
		if(t < d*s){ #if during forced ad exposure period
	     Zap[t] <-0
		} else Zap[t] <- ifelse(y.star[t]>0,1,0)
		tau <- t-1
		if(Zap[t]>0) break #if zap, stop simulating data
	}
	result <- rbind(e,e.star,y,y.star,Zap,dt,replicate(T+1, c(z,Ad,tau)))
	rownames(result) <- NULL # in case of the rownames "Duplicate names not supported."
	return(result)
}
t.combine <- aperm(aaply(t.e.0, 1, simulate.e),c(1,3,2)) #simulate et, e.start, yt, y.start and z over i and j
t.e <- t.combine[,,1:P]
e.star <- t.combine[,2:(T+1),(P+1):(2*P)]
t.y <- t.combine[,,(2*P+1)]
t.y.star <- t.combine[,2:(T+1),(2*P+2)]
Zap <- t.combine[,2:(T+1),(2*P+3)]
d <- t.combine[,2:(T+1),(2*P+4)]
d.mod <- t.combine[,,(2*P+4)]
z <- t.combine[,2:(T+1),(2*P+5):(2*P+4+M)]
z.mod <- t.combine[,,(2*P+5):(2*P+4+M)]
Ad <- t.combine[,2:(T+1),(2*P+5+M):(2*P+4+M+J)]
Ad.mod <- t.combine[,,(2*P+5+M):(2*P+4+M+J)]
Ad.sum <- t.combine[,1,(2*P+5+M):(2*P+4+M+J)]
tau <- t.combine[,2:(T+1),(2*P+5+M+J)]
tau.mod <- t.combine[,,(2*P+5+M+J)]
tau.sum <- t.combine[,1,(2*P+5+M+J)]

##Check the distribution
hist(tau.sum[Ad.sum[,1]==0 & Ad.sum[,2]==0],breaks=30,main="Distribution of duration for simulated data",xlab="Duration(s)",ylab="Density")
hist(tau.sum[Ad.sum[,1]==1],breaks=30,main="Distribution of duration for simulated data",xlab="Duration(s)",ylab="Density")
hist(tau.sum[Ad.sum[,2]==1],breaks=30,main="Distribution of duration for simulated data",xlab="Duration(s)",ylab="Density")
#-------------------------------------------------------------------------------------------------------------------------------------------#
tau.sum[tau.sum==1]


### Priors
m.v <- 4
psi.v <- diag(1,P)
beta.beta.tilda.hat <- rep(0,P+3+M+J)
sigma.beta.beta.tilda.hat <- diag(1e2,P+3+M+J)
a <- 1
b <- 1
delta.hat <- rep(0,P)
sigma.delta.hat <-  diag(1e2,P)
r.e.hat <- rep(0,P)
sigma.r.e.hat <- diag(1e2,P)
r.u.hat <- rep(0,P)
sigma.r.u.hat <- diag(1e2,P)
m.w <- 4
psi.w <-diag(1,P)

### Priors for state variables 
m0.e <- rep(0,3*P) #dlm state variable include r and u
C0.e <- diag(1e2,3*P)
m0.y <- c(-5,rep(0,(P+2+M+J)))
C0.y <- diag(1e2,P+3+M+J)


#-------------------------------------------------------------------------------------------------------------------------------------------#


##################################################              Test   data                 #################################################
K <- 5000
V <- replicate(K,c(t.V))
beta <- replicate(K,t.beta)
beta.tilda <- replicate(K,t.beta.tilda)
sigma.w2 <- t(rep(t.sigma.w2,K))
delta <- replicate(K,t.delta)
r.e <- replicate(K,t.r.e)
u.e <- replicate(K,t.u.e)
W <- replicate(K,c(t.W))
par <- list(V,beta,beta.tilda,sigma.w2,delta,r.e,u.e,W)
names(par)<-c("V","beta","beta.tilda","sigma.w2","delta","r.e","u.e","W")


par$V <- matrix(0,P*P,K) 
par$delta <- matrix(0,P,K)
par$r.e <- matrix(0,P,K)
par$u.e <- matrix(0,P,K)
par$W <- matrix(0,P*P,K) 
par$beta <- matrix(0,P,K)      
par$beta.tilda <- matrix(0,3+M+J,K)
par$sigma.w2 <- matrix(0,1,K)
e <- array(0,c(N,T+1,P,K))
y.star<- array(0,c(N,T,K))
y <- array(0,c(N,T+1,K))

#START FROM TRUE VALUE
par$V[,1] <- c(t.V) 
par$delta[,1] <- t.delta
par$r.e[,1] <- t.r.e
par$u.e[,1] <- t.u.e     
par$W[,1]<-c(t.W) 
par$beta[,1] <- t.beta
par$beta.tilda[,1] <- t.beta.tilda
par$sigma.w2[1] <- t.sigma.w2
e[,,,1] <- t.e
y.star[,,1] <-t.y.star
y[,,1]<-t.y

#START FROM RANDOM
par$V[,1] <- c(1,0,0,1) 
par$delta[,1] <- c(0.5,0.3)
par$r.e[,1] <- c(1,1)
par$u.e[,1] <- c(1,1)
par$W[,1]<-c(1,0,0,1)
par$beta[,1] <- c(1,3)
par$beta.tilda[,1] <- c(1,10,3,1,1,1,1)
par$sigma.w2[1] <- 1
e[,,,1] <-  abind(array(0,c(N,1,P)),(e.star*0.9),along=2)
y[,,1] <-abind(array(0,c(N,1)),(t.y.star*0.9),along=2)
y.star[,,1] <-t.y.star

########Plus time test#######
for(k in 863:(K-1)){
  ptm <- proc.time()
  par$V[,k+1] <- c(Sample.V(m.v,psi.v,e.star,e[,2:(T+1),,k]))                                                                                         #Generate V
  ptm.V <- proc.time()
  ptm.V -ptm
  e[,,,k+1] <- Sample.e(m0.e, C0.e, e.star, d, matrix(par$V[,k+1],P,P), par$delta[,k], par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))               #Generate e
  ptm.e<- proc.time()
  ptm.e-ptm.V
  par$delta[,k+1] <- Sample.delta(delta.hat, sigma.delta.hat, e[,,,k+1], d.mod, par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))                      #Generate delta
  ptm.delta<- proc.time()
  ptm.delta-ptm.e
  par$r.e[,k+1] <- Sample.r.e(r.e.hat, sigma.r.e.hat, e[,,,k+1], d.mod, par$delta[,k+1], par$u.e[,k], matrix(par$W[,k],P,P))                          #Generate r.e
  ptm.r<- proc.time()
  ptm.r - ptm.delta
  par$u.e[,k+1]<-Sample.u.e(r.u.hat, sigma.r.u.hat, e[,,,k+1], d.mod, par$delta[,k+1], par$r.e[,k], matrix(par$W[,k],P,P))                            #Generate u.e
  ptm.u<- proc.time()
  ptm.u -ptm.r
  par$W[,k+1] <- c(Sample.W(m.w , psi.w ,e[,,,k], d.mod, par$delta[,k+1], par$r.e[,k+1], par$u.e[,k+1]))                                              #Generate W
  ptm.W<- proc.time()
  ptm.W -ptm.u
  y.star[,,k+1] <- Sample.y.star(y[,2:(T+1),k], Zap, d)                                                                                               #Generate y.star
  ptm.probit<- proc.time()
  ptm.probit -ptm.W
  y[,,k+1] <- Sample.y(m0.y, C0.y, y.star[,,k+1], d, e[,1:T,,k+1], z, Ad, par$beta[,k], par$beta.tilda[,k], par$sigma.w2[,k])                         #Generate y
  ptm.y<- proc.time()
  ptm.y -ptm.probit
  beta.beta.tilda <- Sample.beta.beta.tilda(beta.beta.tilda.hat, sigma.beta.beta.tilda.hat, y[,,k+1], e[,,,k+1],d.mod,z.mod,Ad.mod,par$sigma.w2[,k])  #Generate beta&beta.tilda
  par$beta[,k+1] <- beta.beta.tilda[1:P]
  par$beta.tilda[,k+1] <- beta.beta.tilda[(P+1):(P+3+M+J)]
  ptm.beta<- proc.time()
  ptm.beta -ptm.y
  par$sigma.w2[,k+1] <- Sample.sigma.w2(a, b, y[,,k+1], e[,,,k+1], d.mod,z.mod,Ad.mod, par$beta[,k+1], par$beta.tilda[,k+1])#Generate sigma.w2
  ptm.sigma.w2<- proc.time()
  ptm.sigma.w2-ptm.y
  proc.time()-ptm
  print(k)
  print(beta.beta.tilda)
  print(par$sigma.w2[,k+1])
  if(k%%100==1){
    par.post <- rbind(par$V[,1:(k+1)],par$delta[,1:(k+1)],par$r.e[,1:(k+1)],par$u.e[,1:(k+1)],par$W[,1:(k+1)],par$beta[,1:(k+1)],par$beta.tilda[,1:(k+1)],par$sigma.w2[,1:(k+1)]) 
    write.csv(par.post,"y_par_all_Simulated_Data_iter10000.csv")
  }
}



###################################################################################

#                            Generating Functions                                 #
###########################   1.Generate y.star      ############################## 
# truncated normal function
#rtnorm <- function(n, mu, sigma, lower=-Inf, upper=Inf){
#	u.l <- pnorm(lower, mu, sigma)
#	u.u <- pnorm(upper, mu, sigma)
#	u <- runif(n, u.l, u.u)
#	z <- qnorm(u, mu, sigma)
#	return(z)
#}

# Sample the latent ystar
Sample.y.star <- function(y, Zap, d ){
	zl <- array(-Inf, c(N, T))
	zu <- array(Inf, c(N, T))
  Sample.y.star.n  <- function(x){
		x[,1][x[,3]==1 & x[,4]==0 ] <- 0
		x[,2][x[,3]==0 & x[,4]==0 ] <- 0
		y.star.n <- rep(0,T)
		y.star.n[1:x[1,5]] <- aaply(x[1:x[1,5],], 1, function(x){rtruncnorm(1, x[1], x[2], x[6], 1)})
		return(y.star.n)
	}
	y.star <- aaply(abind(zl, zu, Zap, d, tau, y, along=3),1, Sample.y.star.n) # For matrix T*6 with zl,zu,Zap,d,tau,y
	return(y.star)
}
#y.star[,,k+1] <- Sample.y.star(y[,2:(T+1),k], Zap, d)

######################################    2.Generate V    ######################################### 
Sample.V <- function(m, psi, e.star, e) ## e[,2:(T+1),]
{
	m.star <- m + sum(tau.sum)
	e.res.split <- aaply(e.star-e,1,function(x) crossprod(x))  # caculate (e*t-et)(e*t-et)' for each n
	e.res.combine <- apply(e.res.split,c(2,3),sum) # sum up over n
	psi.star <- psi + e.res.combine
	return(riwish(m.star,psi.star))
}

#####################################    3.Generate e    ######################################### 
#FFBS for e
Sample.e <- function(m0, C0, e.star, d, V, delta, r, u, W){
	Sample.e.n <- function(x){ #FFBS for each i and j
	  e.n <- matrix(0, T+1, P)
	  #specify Gt=(delta,dt,1;0,I,0;0,0,I)
    GG <- bdiag(diag(delta),diag(1,P),diag(1,P))
    GG[1:P,(2*P+1):(3*P)] <- diag(1,P)
    JGG <- matrix(0,3*P,3*P)
    JGG[1:P,(P+1):(2*P)] <- diag(1,P)
    x.tau <- x[2,(3*P+2)] #define watching duration
  	dlr <- dlm(FF = diag(1,3*P), V = bdiag(V,diag(0,P),diag(0,P)), GG = GG, W = bdiag(W,diag(0,P),diag(0,P)) , m0 = m0, C0 = C0, JGG = JGG, X = x[1:x.tau,3*P+1])
  	#ptm.n <- proc.time()
  	FFilter <- dlmFilter(y = x[1:x.tau,1:(3*P)], mod= dlr, debug = FALSE, simplify = FALSE) #Forward Filter
  	#ptm.Filter.n <- proc.time()
  	#print(ptm.Filter.n-ptm.n)
  	BSample <- dlmBSample(FFilter)  #Backward Sampling
	  e.n[1:(x.tau+1),] <- BSample[1:(x.tau+1),1:P]
	  #ptm.Sample.n <- proc.time()
	  #print(ptm.Sample.n - ptm.Filter.n)
    return(e.n)	
    }
    #For matrix T*(3*P+2) with e.star,r,u,d,tau
	  e <- aaply(abind(e.star,aperm(array(r,c(P,N,T)),c(2,3,1)),aperm(array(u,c(P,N,T)),c(2,3,1)),d,tau,make.names=TRUE),1,Sample.e.n) 
}
#e[,,,k+1] <- Sample.e(m0.e, C0.e, e.star, d, matrix(par$V[,k+1],P,P), par$delta[,k], par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))  

#-------------------------- (Alternatives)  3.Generate e & r (estimate r in viewing instance level)   --------------------------# 
#FFBS for e
Sample.e.r <- function(m0, C0, e.star, d, V, delta, r, u, W, tau){
	Sample.e.i.j <- function(x){ #FFBS for each i and j
	e.i.j <- matrix(0, T+1, P)
	#specify Gt=(delta,dt,1;0,1,0;0,0,1)
    GG <- bdiag( diag(delta),1,1)
    GG[1:P,P+2] <- rep(1,P)
    JGG <- matrix(0,P+2,P+2)
    JGG[1:P,P+1] <- rep(1,P)
    x.tau <- x[2,P+2] #define watching duration
	  dlr <- dlm(FF = cbind(diag(rep(1,P)),matrix(0,P,2)), V = V, GG = GG, W = bdiag(W,0,0) , m0 = m0, C0 = C0, JGG = JGG, X = x[1:x.tau,P+1])
	  FFilter <- dlmFilter(y = x[1:x.tau,1:P], mod= dlr, debug = FALSE, simplify = FALSE) #Forward Filter
	  BSample <- dlmBSample(FFilter) #Backward Sampling
	  e.i.j[1:x.tau,] <- BSample[1:(x.tau+1),1:P]
    return(e.i.j)	
    }   
	e <- aaply(abind(e.star,d,tau.mod),c(1,2),Sample.e.i.j) #For matrix T*(P+2) with e.star,d,tau.mod
}

#e[,,,,k+1] <- Sample.e(m0.e, C0.e, e.star, d, matrix(par$V[,k+1],P,P), par$delta[,k], par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P), tau.mod)

###########################    4.Generate y    ############################## 
Sample.y <- function(m0, C0, y.star, d, e, z, Ad, beta, beta.tilda, sigma.w2){
	Sample.y.n <- function(x){ #FFBS for each n
	  y.n <- rep(0,T+1)
	  #specify Gt=(rho,et-1,dt,eta,phi,1;1,0,1,0,0;0,0,1,0;0,0,0,1)
    GG <- diag(c(beta.tilda[1],rep(1,P+2+M+J)))
    GG[1,(P+3):(P+3+M+J)]<-c(x[1,(2*P+5+M+J):(2*(P+M+J)+4)],1)
    JGG <- matrix(0,P+3+M+J,P+3+M+J)
    JGG[1,P+2] <- 1
    JGG[1,2:(P+1)] <- c(2:(P+1))
    x.tau <- x[2,(2*(P+M+J)+5)] #define watching duration
    #x=(dt,et-1,Z,Ad)
	  dlr <- dlm(FF = diag(1,P+3+M+J), V = bdiag(1,diag(0,P+2+M+J)), GG = GG, W = bdiag(sigma.w2,diag(0,P+2+M+J)), m0 = m0, C0 = C0, JGG = JGG, X = x[1:x.tau,(P+4+M+J):(2*P+4+M+J)])  
	  FFilter <- dlmFilter(y = x[1:x.tau,1:(P+3+M+J)], mod= dlr, debug = FALSE, simplify = FALSE) #Forward Filter
	  BSample <- dlmBSample(FFilter) #Backward Sampling
	  y.n[1:(x.tau+1)] <- BSample[1:(x.tau+1),1]
    return(y.n)	
    }    
    #For matrix T*((2*(P+M+J)+5) with ystar,beta,r,eta,phi,u,d,e,z,Ad,tau 
	y <- aaply(abind(y.star,aperm(array(beta,c(P,N,T)),c(2,3,1)),aperm(array(beta.tilda[2:(3+M+J)],c(2+M+J,N,T)),c(2,3,1)),d,e,z,Ad,tau,make.names=TRUE),1,Sample.y.n) # Only need et-1
	return(y)
}
#y[,,k+1] <- Sample.y(m0.y, C0.y, y.star[,,k+1], d, e[,1:T,,k+1], z, Ad, par$beta[,k], par$beta.tilda[,k], par$sigma.w2[,k])

###########################   5 & 6.Generate beta & beta.tilda (if beta is time-invariant)   ##############################
Sample.beta.beta.tilda <- function( u, sigma, y, e, d, z, Ad, sigma.w2){
    beta.res.sum<-function(x){
    	x.tau <- x[2,P+3+M+J]
    	#xt=(et-1,yt-1,dt,z,ad,1)
    	X <- unname(cbind(x[1:x.tau,1:(P+1)],x[2:(x.tau+1),(P+2):(P+2+M+J)],rep(1,x.tau))) 
    	y <- x[2:(x.tau+1),(P+1)]                                            
    	sum.sigma <- crossprod(X) * (1/sigma.w2)
    	sum.u <- crossprod(X,y) * (1/sigma.w2)
    	return(rbind(sum.sigma,t(sum.u)))	
    }
                      
    sum.split<-aaply(abind(e,y,d,z,Ad,tau.mod,make.names=TRUE),1,beta.res.sum)   #for each n, matrix (T+1)*(P+3+M+J) with e,y,d,z,Ad,tau #for each n, matrix (T+1)*(P+3+M+J) with e,y,d,z,Ad,tau
    sum.combine <- apply(sum.split,c(2,3),sum)                                   #sum up over n
    sigma.sum <- sum.combine[1:(P+3+M+J),]
    u.sum <- sum.combine[P+4+M+J,]   
    sigma.star <- solve (solve(sigma) + sigma.sum)
    u.star <- sigma.star %*% (solve(sigma) %*% u + u.sum)    
	  return(rmvnorm(1, u.star, sigma.star))
}
#Sample.beta.beta.tilda(beta.beta.tilda.hat, sigma.beta.beta.tilda.hat, y[,,k+1], e[,,,k+1],d.mod,z.mod,Ad.mod,par$sigma.w2[,k])

#-------------------------- (Alternatives)   5.Generate beta (if beta is time-variant)        --------------------------# 
#-------------------------- (Alternatives)   6.Generate beta.tilda (if beta is time-variant)  --------------------------# 
Sample.beta.tilda <- function( u, sigma, y0, y, d, beta, sigma.w2){
    beta.res.sum<-function(x){ 
    	X <- cbind(c(y0,x[1:(T-1),1]),x[,2],rep(1,T))
    	y <- x[,1]- x[,3:(2+P)] %*% beta
    	sum.sigma <- crossprod(X) * (1/sigma.w2)
    	sum.u <- crossprod(X,y) * (1/sigma.w2)
    	return(rbind(sum.sigma,t(sum.u)))	
    }    
    sum.split <- aaply(abind(y,d,e,make.names=TRUE),c(1,2),beta.res.sum,)  #for each i,j
    sum.combine <- aaply(sum.split,c(3,4),sum) # sum up
    sigma.sum <- sum.combine[1:3,]
    u.sum <- sum.combine[4,]
     
    sigma.star <- solve ( solve(sigma) + sigma.sum)
    u.star <- sigma.star %*% (solve(sigma) %*% u + u.sum)    
  	return(rmvnorm(3, u.star, sigma.star))
}
#par$beta.tilda[,k+1] <- Sample.delta(beta.tilda.hat, sigma.beta.tilda.hat, y[,,,k+1], d, par$beta[,k], par$sigma.w2[,k])

######################################    7.Generate sigma.w2    #######################################
Sample.sigma.w2 <- function(a, b, y, e, d, z, Ad, beta, beta.tilda){
	b.sum<-function(x){
	    x.tau <- x[2,P+3+M+J]
	    X <- unname(cbind(x[1:x.tau,1:(P+1)],x[2:(x.tau+1),(P+2):(P+2+M+J)],rep(1,x.tau))) #xt=(et-1,yt-1,dt,z,ad,1)
	    y <- x[2:(x.tau+1),(P+1)]                                                          #yt
    	res <- y -X %*% c(beta, beta.tilda)
    	sum <- crossprod(res)
    	return(sum)
    }
	b.res.split <- aaply(abind(e,y,d,z,Ad,tau.mod,make.names=TRUE),1,b.sum)  #for each n, matrix (T+1)*(P+3+M+J) with e,y,d,z,Ad,tau
  b.res.combine <- sum(b.res.split)                                    # sum up over n
	return(1/rgamma(1, a + sum(tau.sum)/2, rate = b + b.res.combine/2))
} 

###########################    8.Generate delta (if delta is diagnal)    ##############################
Sample.delta <- function(u, sigma, e, d, r, u.e, W){
	 delta.res.sum<-function(x){
	   T <- x[2,P+2]
     Z <- aaply (matrix(x[1:T,],T,P+2), 1, function(x) {diag(x[1:P])})
     res <- x[2:(T+1),1:P]- replicate(P,x[2:(T+1),P+1]) %*% diag(r) - t(as.matrix(replicate(T,u.e)))
     sum.sigma.t <- aaply(Z,1,function(x)t(x)%*%solve(W)%*%x)
     sum.sigma <- aaply(sum.sigma.t,c(2,3),sum)
     sum.u.t <- aaply(abind(Z,res),1,function(x) t(x[,1:P])%*%solve(W)%*%x[,P+1])
     sum.u <- aaply(sum.u.t,2,sum)
     return(rbind(sum.sigma,t(sum.u)))
    }
    sum.split <- aaply(abind(e,d,tau.mod,make.names=TRUE),1,delta.res.sum) #for each n, matrix (T+1)*(P+1) with e, d ,tau.mod
    sum.combine <- apply(sum.split,c(2,3),sum)                                      #sum up
    sigma.sum <- sum.combine[1:P,]
    u.sum <- sum.combine[P+1,]
    
    sigma.star <- solve ( solve(sigma) + sigma.sum)
    u.star <- sigma.star %*% (solve(sigma) %*% u + u.sum)    
	return(rmvnorm(1,u.star, sigma.star))
}

#par$delta[,k+1] <- Sample.delta(delta.hat, sigma.delta.hat, e, d.mod, par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))

####################################    9.Generate r.e   ############################################
Sample.r.e <- function(u, sigma, e, d, delta, u.e, W){	
    r.e.res.sum <-function(x){
    	T <- x[2,P+2]
    	D <- aaply (matrix(x[2:(T+1),],T,P+2), 1, function(x) {diag(x[P+1],P)})
    	res <- x[2:(T+1),1:P] - x[1:T,1:P] %*% diag(delta) - t(as.matrix(replicate(T,u.e)))
    	sum.sigma.t <- aaply(D,1,function(x)t(x)%*%solve(W)%*%x)
    	sum.sigma <- aaply(sum.sigma.t,c(2,3),sum)
    	sum.u.t <- aaply(abind(D,res),1,function(x) t(x[,1:P])%*%solve(W)%*%x[,P+1])
    	sum.u <- aaply(sum.u.t,2,sum)
    	return(rbind(sum.sigma,t(sum.u)))
    }
    sum.split <- aaply(abind(e,d, tau.mod,make.names=TRUE),1,r.e.res.sum) #for each n
    sum.combine <- apply(sum.split,c(2,3),sum)                            # sum up
    sigma.sum <- sum.combine[1:P,]
    u.sum <- sum.combine[P+1,]
    
    sigma.star <- solve ( solve(sigma) + sigma.sum)
    u.star <- sigma.star %*% (solve(sigma) %*% u + u.sum)    
	return(rmvnorm(1,u.star, sigma.star))
}

#par$r.e[,k+1] <- Sample.r.e(r.e.hat, sigma.r.e.hat, e, d.mod, par$delta[,k+1], par$u.e[,k], matrix(par$W[,k],P,P))

##########################################   10.Generate u.e   #############################################
Sample.u.e <- function(u, sigma, e, d, delta, r, W){
    u.e.res.sum<-function(x){
      T <- x[2,P+2]
    	I <- aaply (matrix(x[2:(T+1),],T,P+2), 1, function(x) {diag(rep(1,P))})
    	res <- x[2:(T+1),1:P] - x[1:T,1:P] %*% diag(delta) - replicate(P,x[2:(T+1),P+1]) %*% diag(r)
    	sum.sigma.t <- aaply(I,1,function(x)t(x)%*%solve(W)%*%x)
    	sum.sigma <- aaply(sum.sigma.t,c(2,3),sum)
    	sum.u.t <- aaply(abind(I,res),1,function(x) t(x[,1:P])%*%solve(W)%*%x[,P+1])
    	sum.u <- aaply(sum.u.t,2,sum)
     return(rbind(sum.sigma,t(sum.u)))
    }
    sum.split <- aaply(abind(e,d,tau.mod,make.names=TRUE)[1:100,,],1,u.e.res.sum) #for each n
    sum.combine <- apply(sum.split,c(2,3),sum)                           #sum up over n
    sigma.sum <- sum.combine[1:P,]
    u.sum <- sum.combine[P+1,]
    
    sigma.star <- solve ( solve(sigma) + sigma.sum)
    u.star <- sigma.star %*% (solve(sigma) %*% u + u.sum)    
	return(rmvnorm(1,u.star, sigma.star))
}
# par$u.e[,k+1]<-Sample.u.e(r.u.hat, sigma.r.u.hat, e, d.mod, par$delta[,k+1], par$r.e[,k], matrix(par$W[,k],P,P)) 

##########################################   11.Generate W   ###############################################
Sample.W<-function(m, psi, e, d, delta, r, u.e){
	  m.star <- m + sum(tau.sum)
	  psi.sum<-function(x){
  	T <- x[2,P+2]
    e <- x[2:(T+1),1:P] - x[1:T,1:P] %*% diag(delta) - replicate(P,x[2:(T+1),P+1]) %*% diag(r) - t(as.matrix(replicate(T,u.e)))
    sum<-crossprod(e)
    return(sum)
    }
	e.res.split <- aaply(abind(e,d,tau.mod,make.names=TRUE),1, psi.sum) 
	e.res.combine <- apply(e.res.split,c(2,3),sum)
	psi.star <- psi + e.res.combine
	return(riwish(m.star,psi.star))
}
#par$W[,k+1] <- c(Sample.W(m.w , psi.w ,e[,,,k], d.mod, par$delta[,k+1], par$r.e[,k+1], par$u.e[,k+1]))



######### Iterations ######
for(k in 1:(K-1)){
	y.star[,,k+1] <- Sample.y.star(y[,2:(T+1),k], Zap, d)                                                                                               #Generate y.star
	par$V[,k+1] <- c(Sample.V(m.v,psi.v,e.star,e[,2:(T+1),,k]))                                                                                         #Generate V
	e[,,,k+1] <- Sample.e(m0.e, C0.e, e.star, d, matrix(par$V[,k+1],P,P), par$delta[,k], par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))               #Generate e
	y[,,k+1] <- Sample.y(m0.y, C0.y, y.star[,,k+1], d, e[,1:T,,k+1], z, Ad, par$beta[,k], par$beta.tilda[,k], par$sigma.w2[,k])                     #Generate y
	beta.beta.tilda <- Sample.beta.beta.tilda(beta.beta.tilda.hat, sigma.beta.beta.tilda.hat, y[,,k+1], e[,,,k+1],d.mod,z.mod,Ad.mod,par$sigma.w2[,k])  #Generate beta&beta.tilda
	par$beta[,k+1] <- beta.beta.tilda[1:P]
  par$beta.tilda[,k+1] <- beta.beta.tilda[(P+1):(P+3+M+J)]
  par$sigma.w2[,k+1] <- Sample.sigma.w2(a, b, y[,,k+1], e[,,,k+1], d.mod,z.mod,Ad.mod, par$beta[,k+1], par$beta.tilda[,k+1])                          #Generate sigma.w2
  par$delta[,k+1] <- Sample.delta(delta.hat, sigma.delta.hat, e[,,,k+1], d.mod, par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))                      #Generate delta
  par$r.e[,k+1] <- Sample.r.e(r.e.hat, sigma.r.e.hat, e[,,,k+1], d.mod, par$delta[,k+1], par$u.e[,k], matrix(par$W[,k],P,P))                          #Generate r.e
  par$u.e[,k+1]<-Sample.u.e(r.u.hat, sigma.r.u.hat, e[,,,k+1], d.mod, par$delta[,k+1], par$r.e[,k], matrix(par$W[,k],P,P))                            #Generate u.e
  par$W[,k+1] <- c(Sample.W(m.w , psi.w ,e, d.mod, par$delta[,k+1], par$r.e[,k+1], par$u.e[,k+1]))                                              #Generate W
    }


######################################Real Data 1.e part#####################################

### Priors
m.v <- 10
psi.v <- diag(1,P)
delta.hat <- rep(0,P)
sigma.delta.hat <-  diag(1e2,P)
r.e.hat <- rep(0,P)
sigma.r.e.hat <- diag(1e2,P)
r.u.hat <- rep(0,P)
sigma.r.u.hat <- diag(1e2,P)
m.w <- 10
psi.w <-diag(1,P)

### Priors for state variables 
m0.e <- rep(0,3*P) #dlm state variable include r and u
C0.e <- diag(1e2,3*P)


##Initialization
V <- replicate(K,c(diag(0.25,P)))
delta <- replicate(K,rep(1,P))
r.e <- replicate(K,c(2,-5,5,5,-5,5,5,5))
u.e <- replicate(K,rep(-0.5,P))
W <- replicate(K,c(diag(0.25,P)))
par <- list(V,delta,r.e,u.e,W)
names(par)<-c("V","delta","r.e","u.e","W")
par$V <- matrix(0,P*P,K) 
par$delta <- matrix(0,P,K)
par$r.e <- matrix(0,P,K)
par$u.e <- matrix(0,P,K)
par$W <- matrix(0,P*P,K) 

par$V[,1] <- c(diag(0.25,P))
par$delta[,1] <- rep(1,P)
par$r.e[,1] <- c(2,-5,5,5,-5,5,5,5)
par$u.e[,1] <- rep(-0.5,P)   
par$W[,1]<-c(diag(0.25,P)) 

# Structure for state variable e,y
#e <- array(0,c(N,T+1,P,K))
e <- abind(array(0,c(N,1,P)),e.star*0.9,along=2)

for(k in 1:(K-1)){
  par$V[,k+1] <- c(Sample.V(m.v,psi.v,e.star,e[,2:(T+1),]))                                                                                 #Generate V
  e <- Sample.e(m0.e, C0.e, e.star, d, matrix(par$V[,k+1],P,P), par$delta[,k], par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))             #Generate e
  par$delta[,k+1] <- Sample.delta(delta.hat, sigma.delta.hat, e, d.mod, par$r.e[,k], par$u.e[,k], matrix(par$W[,k],P,P))                    #Generate delta
  par$r.e[,k+1] <- Sample.r.e(r.e.hat, sigma.r.e.hat, e, d.mod, par$delta[,k+1], par$u.e[,k], matrix(par$W[,k],P,P))                        #Generate r.e
  par$u.e[,k+1]<-Sample.u.e(r.u.hat, sigma.r.u.hat, e, d.mod, par$delta[,k+1], par$r.e[,k], matrix(par$W[,k],P,P))                          #Generate u.e
  par$W[,k+1] <- c(Sample.W(m.w , psi.w ,e, d.mod, par$delta[,k+1], par$r.e[,k+1], par$u.e[,k+1]))                                          #Generate W
  print(par$V[,k+1])
  print(par$delta[,k+1])
  print(par$r.e[,k+1])
  print(par$u.e[,k+1])
  print(par$W[,k+1])
  print(k)  
  if(k%%100==1){
    par.post <- rbind(par$V[,1:(k+1)],par$delta[,1:(k+1)],par$r.e[,1:(k+1)],par$u.e[,1:(k+1)],par$W[,1:(k+1)]) 
    write.csv(par.post,"e1_par_Real_Data_iter30000.csv")
    write.csv(e,"e1_value_Real_Data_iter30000.csv")
  }
}

  par.post <- rbind(par$V[,1:K],par$delta[,1:K],par$r.e[,1:K],par$u.e[,1:K],par$W[,1:K])
  post.chain<-mcmc(t(par.post))
  #print(summary(post.chain))
  #par(mfrow=c(P,P))
  #traceplot(post.chain[,1:(P*P)], main="Posterior for V") 
  #par(mfrow=c(P,1))
  #traceplot(post.chain[,(P*P+1):(P*P+P)], main="Posterior for delta")
  #par(mfrow=c(P,1))
  #traceplot(post.chain[,(P*P+P+1):(P*P+2*P)], main="Posterior for r.e")
  #par(mfrow=c(P,1))
  #traceplot(post.chain[,(P*P+2*P+1):(P*P+3*P)], main="Posterior for u.e")
  #par(mfrow=c(P,P))
  #traceplot(post.chain[,(P*P+3*P+1):(P*P+3*P+P*P)], main="Posterior for W")   
